# 아키텍처

## 시스템 개요

Orchestra CLI는 각각 특정 책임과 명확한 통신 프로토콜을 가진 3개의 계층으로 구성된 계층적 에이전트 아키텍처를 구현합니다.

## 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────┐
│  사용자 (CLI)                                            │
└────────────────────┬────────────────────────────────────┘
                     │ orchestra run "작업 설명"
                     ▼
┌─────────────────────────────────────────────────────────┐
│  L1 Orchestrator                                         │
│  - 설정 로드 (orchestra.config.yaml)                     │
│  - 정책 적용 (보안, 리소스 제한)                          │
│  - 라우팅 & 라이프사이클 관리                             │
│  - 관찰성 (로그, 메트릭, 런 디렉토리)                      │
└────────────────────┬────────────────────────────────────┘
                     │ task_context → L2
                     ▼
┌─────────────────────────────────────────────────────────┐
│  L2 Coordinator                                          │
│  - Claude Code LLM 호출 (planner prompt)                 │
│  - DAG/단계별 계획 생성 (의존성 그래프)                    │
│  - L3용 task 메시지 생성                                 │
└────────────────────┬────────────────────────────────────┘
                     │ tasks[] → L3 workers (병렬/순차)
                     ▼
┌─────────────────────────────────────────────────────────┐
│  L3 Worker(s)                                            │
│  - 화이트리스트 도구 실행 (echo, ls, lint 등)             │
│  - 결과/아티팩트 수집                                     │
│  - 실패 시 재시도 (exponential backoff)                   │
└────────────────────┬────────────────────────────────────┘
                     │ results[], artifacts[] ↑
                     ▼
        ┌─────────────────────────────┐
        │  ./runs/{timestamp}/        │
        │  - plan.json                │
        │  - tasks.jsonl              │
        │  - artifacts/               │
        │  - report.md                │
        └─────────────────────────────┘
                     │
                     ▼ (최종 요약 & 출력)
                 사용자 콘솔
```

## 데이터 흐름

### 1. 하향 흐름 (작업 분해)
1. **L1 → L2**: `{intent, constraints, config}`
2. **L2 → L3**: `{task_id, parent_id, tools, inputs, ...}`

### 2. 상향 흐름 (결과 집계)
3. **L3 → L2 → L1**: `{state, logs[], artifacts[], metrics}`

## 실행 모델

### 단계별 실행을 포함한 동기식 CLI
- **1단계: 계획** - L2가 작업 그래프 생성
- **2단계: 승인** (MVP에서는 암묵적) - 사용자가 `--plan-only`로 검토 가능
- **3단계: 실행** - L3 워커가 작업 실행
- **4단계: 집계** - L1이 결과를 수집하고 리포트 생성

### 동시성 모델
- L3 워커는 제한된 동시성(`--concurrency` 플래그)으로 병렬 실행
- 작업 의존성은 필요한 경우 순차 실행 강제
- 실패한 작업에 대한 지수 백오프 재시도

## 작업 그래프 구조

L2는 DAG(방향성 비순환 그래프) 또는 순서가 있는 단계를 생성합니다:
- 각 노드는 작업을 나타냄 (메시지 스키마 참조)
- 엣지는 의존성을 나타냄
- L1이 라이프사이클을 관리하고 `./runs/{timestamp}/plan.json`에 저장

## 안전 메커니즘

1. **도구 화이트리스팅**: L3는 설정에 선언된 도구만 호출 가능. 기본적으로 거부.
2. **파일시스템 보안**: 기본적으로 읽기 전용, 지정된 경로에만 쓰기 허용
3. **네트워크 격리**: 명시적으로 화이트리스트되지 않는 한 네트워크 접근 비활성화
4. **비밀 정보 마스킹**: PII/비밀 정보가 로그에서 자동으로 마스킹됨
5. **타임아웃**: 작업별 및 전체 런 타임아웃 강제

## 관찰성

- 모든 작업은 `timestamp`, `trace_id`, `task_id`, `level`, `message`, `payload`가 포함된 JSONL 이벤트를 발생
- 런 디렉토리 구조는 모든 실행 아티팩트를 보존
- 완료 시 마크다운 요약 리포트 생성

## LLM 프로토콜 (Claude Code)

### Planner 프롬프트 (L2)
- 입력: 사용자 의도, 제약사항, 화이트리스트 도구
- 출력: 의존성이 포함된 JSON 배열 작업
- Few-shot 예제로 일관된 포맷 보장

### Summarizer 프롬프트 (L1)
- 입력: 작업 결과, 아티팩트, 메트릭
- 출력: 마크다운 요약 리포트

두 프롬프트 모두 `orchestra.config.yaml`에 저장되며 배포별로 커스터마이징 가능합니다.
